# 树

![1625893592445](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625893592445.png)





# 树的基本结构

![1625893707117](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625893707117.png)

**树的定义：**

- 空树：树的节点个数为0
- 根节点：非空树必存在一个节点为根节点

- 全树：以根节点为根
- 子树：以非根节点为根
- 节点的度：节点分支的个数
- 树的度：所有节点中最大的度
- 叶子节点：度为0的节点
- 分支节点：度大于0的节点
- 层次：**从上往下**递增（根节点为0层）
- 深度：最大层次
- 高度：**从下往上**递增
- 树的高度：根节点的高度
- 森林：彼此不相交的树的集合





# 树的分类

## 有序树

树的任意节点的子节点有顺序关系。



## 无序树

树的任意节点的子节点没有顺序关系。



## 二叉树

定义：二叉树的每个结点**至多**只有**两个**子树（分支），子树有左右之分，次序不能颠倒

性质：

- 第 i 层至多有  **2^i** 个结点(i>=0)
- 高度为 k 的二叉树最多有 **2^(k+1) - 1** 个结点(k>=-1)(空树的高度为-1)
- 对任何一棵二叉树，如果其叶子结点(度为0)数为m, 度为2的结点数为n, 则m = n + 1



二叉树又分为：满二叉树，完全二叉树，完满二叉树

### **1. 满二叉树**



![img](https://upload-images.jianshu.io/upload_images/4630295-e8794f687ebce60f.png?imageMogr2/auto-orient/strip|imageView2/2/w/316/format/webp)

### **2. 完全二叉树**



![img](https://upload-images.jianshu.io/upload_images/4630295-cb3ad122f232bdd0.png?imageMogr2/auto-orient/strip|imageView2/2/w/312/format/webp)

### **3. 完满二叉树**



![img](https://upload-images.jianshu.io/upload_images/4630295-60dfd9a13e550826.png?imageMogr2/auto-orient/strip|imageView2/2/w/191/format/webp)



**区别：**

![1625896185875](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625896185875.png)



### 4. 线索二叉树

为了充分利用节点的指针域，按照某种遍历次序进行遍历二叉树的过程中**修改结点的空指针**，使其指向其在该遍历次序下的**直接前驱**或**直接后继**

![1625908820075](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625908820075.png)

线索二叉树的结点

并约定以下规则：

- `left_flag == 0` 时，指针 `left_child` 指向左孩子
- `left_flag == 1` 时，指针 `left_child` 指向直接前驱
- `right_flag == 0` 时，指针 `right_child` 指向右孩子
- `right_flag == 1` 时，指针 `right_child` 指向直接后继



**例如：**（按中序遍历）

![1625909056129](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625909056129.png)



# 二叉树的遍历方法

二叉树的遍历是指从二叉树的**根结点出发**，按照某种次序依次访问二叉树中的所有结点，使得每个结点**被访问一次，且仅被访问一次**

**分为四种：**

- 先序遍历：根-左-右	
- 中序遍历 ：左-根-右
- 后序遍历 ：左-右-根
- 层次遍历：按层遍历，需要借助队列：每次出队一个元素，就将该元素的孩子节点加入队列中，直至队列中元素个数为0时，出队的顺序就是该二叉树的层次遍历结果，**初始状态下，队列中只保留根节点的元素**

深度优先搜索（DFS）、广度优先搜索（BFS）



# 动态查找树

## 1. 二叉查找树

二叉查找树（Binary Search Tree），也称为**二叉搜索树**、**有序二叉树**（ordered binary tree）或**排序二叉树**（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；

- 任意节点的左、右子树也分别为二叉查找树；
- 没有键值相等的节点。



## 2. 平衡二叉树（AVL树）

定义：当且仅当任何节点的两棵子树的**高度差不大于1**的**自平衡二叉查找树**



### **AVL树的自平衡操作—旋转**

![1625900127146](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900127146.png)

- 左旋：是以节点的"右分支"为轴，进行逆时针旋转
- 右旋：是以节点的“左分支"为轴，进行顺时针旋转

**平衡因子**的概念：结点的平衡因子 = 结点的左子树深度 — 结点的右子树深度。**若平衡因子的取值为-1、0或1时，该节点是平衡的，否则是不平衡的**



**分为LL型、RR型、LR型和RL型4种类型：**

#### （1）LL型调整

由于在A的左孩子(L)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1增至2。下面图1是LL型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B顺时针旋转一样。

![1625900285585](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900285585.png)

LL型调整的一般形式如下图2所示，表示在A的左孩子B的左子树BL(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。

**这种情况调整如下：**

①将A的左孩子B提升为新的根结点；

②将原来的根结点A降为B的右孩子；

③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。

![1625900312137](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900312137.png)





#### （2）RR型调整

由于在A的右孩子(R)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图3是RR型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B逆时针旋转一样。

![1625900332513](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900332513.png)

RR型调整的一般形式如下图4所示，表示在A的右孩子B的右子树BR(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。

**这种情况调整如下：**

①将A的右孩子B提升为新的根结点；

②将原来的根结点A降为B的左孩子；

③各子树按大小关系连接(AL和BR不变，BL调整为A的右子树)。

![1625900348394](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900348394.png)



#### （3）LR型调整

由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。

![1625900362577](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900362577.png)

LR型调整的一般形式如下图6所示，表示在A的左孩子B的右子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。

**这种情况调整如下：**

①将C的右孩子B提升为新的根结点；

②将原来的根结点A降为C的右孩子；

③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。

![1625900373202](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900373202.png)



#### （4）RL型调整

由于在A的右孩子(R)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图7是RL型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。

![1625900381290](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900381290.png)

图7  最简单的RL型调整

RL型调整的一般形式如下图8所示，表示在A的右孩子B的左子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。

**这种情况调整如下：**

①将C的右孩子B提升为新的根结点；

②将原来的根结点A降为C的左孩子；

③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)。

![1625900390607](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900390607.png)



## 3. 红黑树

红黑树是一种自平衡的二叉查找树

![1625900982778](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625900982778.png)

性质：

- 性质1：每个节点要么是黑色，要么是红色。
- 性质2：根节点是黑色。
- 性质3：所有叶子都是黑色。（叶子是NIL结点） 
- 性质4：每个红色结点的两个子结点一定都是黑色。
- **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**



### **红黑树自平衡操作—旋转、变色**

https://www.cnblogs.com/-citywall123/p/12588772.html





## 4. 哈夫曼树

哈夫曼树是一种**带权路径长度最短**的二叉树，也称为最优二叉树

![1625904581853](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625904581853.png)

**树的带权路径长度**：为树中**所有叶子结点**的带权路径长度之和。通常记作 **WPL**

```
eg. WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3
```



### 构建哈夫曼树

权重越大的结点离树根越近

**对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：**

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树



## 5. 伸展树（Splay）

Splay 是一种**二叉查找树**，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链

伸展（Splay）是伸展树的核心操作，其最终目的是将节点X一直向上选择直到作为节点R的子节点为止或者将X一直旋转到树的根节点为止。



## 6. 替罪羊树

替罪羊树（Scapegoat TreeScapegoat Tree）可以当作一棵**非常暴力**的**二叉查找树**，因为它除了**在子树不平衡时会暴力重构**以外几乎和BST没有任何区别

**暴力重构的判定：**

我们确定一个比例系数 ![[公式]](https://www.zhihu.com/equation?tex=%5Calpha%5Cin%280.5%2C1%29) ，若左子树或右子树占当前树的比例大于 ![[公式]](https://www.zhihu.com/equation?tex=%5Calpha) ，则进行重构

**重构步骤：**

1. 先进行一遍**中序遍历**，把该子树“拉平”，把其中所有数存入一个数组里
2. 再用这些数据重新建一个平衡的二叉树，放回原位置



暴力重构：

（1）需要重构的子树

![1625909743473](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625909743473.png)

（2）**非常暴力**地将其拍扁

![1625909770504](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625909770504.png)

（3）以最中间的节点为新的根，重新拎起来

![1625909789935](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625909789935.png)



# 多路查找树

大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下



## 1. B树（B-树）

B树（B-tree）是一种**自平衡的树**，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。

**B树（B-树），是一种多路搜索树（并非二叉的）：**

- 定义任意非叶子节点最多可以有M个儿子节点；且M>2
- 则根节点的儿子数为：[2，M]
- 除根节点外的非叶子节点的儿子树为[M/2，M]
- 每个结点存放至少 M/2 - 1 （向上取整）且至多 M -1 个关键字（至少为2）、
- 非叶子结点的关键字个数 = 指向子节点的指针数（p的个数） -1
- 非叶子节点的关键字：K[1],K[2],K[3],…,K[M-1];且K[i] < K[i +1]
- 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于**(K[i-1], K[i])**的子树
- 所有叶子结点位于同一层

**（M = 3）** 

![1625905440388](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625905440388.png)

B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点

**B-树的特性：**

- 关键字集合分布在整颗树中

- **任何一个关键字出现且只出现在一个结点中**（不会重复）

- 搜索有可能在非叶子结点结束

- 其搜索性能等价于在关键字全集内做一次二分查找

- 自动层次控制



## 2. B+树

**B+树是B-树的变体，也是一种多路搜索树：**

其定义基本与B-树同，但部分**有区别**：

- 非叶子结点的关键字个数 = 指向子节点的指针数 （p的个数）

- 非叶子结点的子树指针P[i]，指向关键字值属于**[K[i], K[i+1])**的子树（半开半闭）；


- 为所有叶子结点增加一个链指针；


- 所有关键字都会在叶子结点出现；


**（M=3）**

![1625906627773](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625906627773.png)

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找

**B+树的特性：**

1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；

2.不可能在非叶子结点命中；

3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；



## 3. B*树

B*树是B+树一种变形，它是在B+树的基础上，将索引层以指针连接起来，使搜索取值更加快捷

**（M = 3）**

![1625907190723](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625907190723.png)

但是B树又在B+树的基础上产生了一系列的变化，如下：

- B*树定义了非叶子结点关键字个数至少为(2/3)M（即块的最低使用率为2/3代替B+树的1/2）
- B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针
- *树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针

所以B*树相对于B+树，空间利用率上有所提高，查询速率也有所提高



## **总结**

1. B（B-）树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中，B树的范围查找用的是**中序遍历**
2. B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中，B+树的范围查找用的是在**链表上遍历**
3. B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3










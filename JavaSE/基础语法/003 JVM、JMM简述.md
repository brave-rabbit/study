# JVM 概述

JVM 可以分为 5 个部分

- 类加载器（Class Loader）：加载字节码文件到内存
- **运行时数据区（Runtime Data Area）**：JVM 核心内存空间的结构模型（包括方法区、虚拟机栈、本地方法栈、堆、程序计数器）
- 执行引擎（Execution Engine）：对 JVM 指令进行解析，翻译成机器码，提交给操作系统
- 本地库接口（Native Interface）：供 Java 调用的融合了不同开发语言的原生库
- 本地方法库（Native Libraies）：Java 本地方法的具体实现



## 运行时数据区

jdk 1.8 之后

![1619351748311](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1619351748311.png)

> 方法区

存储**加载的类信息**、常量、**静态成员**和字符串常量池（jdk 1.8之前），方法区是一种**概念、规范**（抽象），**永久代（堆中）是方法区的一种实现**，**元空间（非堆）也是方法区的一种实现**（类似于类实现接口）

**通俗的说**就是：方法区说是存储类信息（包括**静态成员**和**字符串常量池**）的，但最终还是存在永久代中（永久代实现了方法区），jdk1.8 之后，元空间替代了永久代，**类的信息被存储在堆外**，**但是**静态成员和字符串常量池**还存储在堆中**

1.8 以前用的是永久代，1.8以后用的是元空间，除此之外，元空间（或称方法区），不再使用虚拟机内存，而是使用本地内存



> 本地方法栈

执行本地方法

本地方法：Java 是基于应用层的高级编程语言，无法访问底层操作系统，就需要使用其他语言来完成，比如 C++

本地方法的使用原理：

1、在 Java 程序中声明 **native** 修饰的方法，**只有方法定义**，**没有方法实现**，将 Java 文件编译成字节码文件

2、用 **javah** 编译字节码文件，生成一个 .h 文件

3、编写一个 c++  文件，实现 .h 文件中的方法

4、将 c++ 文件编译成动态链接库文件 .dll

5、Java 中使用 System.loadLibrary() 加载动态链接库文件 .dll

**常用的本地方法**

| 方法名     | 描述                         |
| :--------- | :--------------------------- |
| getClass() | 获取运行时类                 |
| hashCode() | 获取对象的哈希值             |
| wait()     | 让正在访问当前资源的线程暂停 |



> 程序计数器

占用内存较小，是**当前**线程所执行的字节码（JVM 指令）**行号指示器**，JVM 通过改变计数器的值来选取下一条要执行的指令

多线程之间的**程序计数器相互独立**，互不影响，为了保证每个线程恢复之后都能回到之前中断的位置，进而继续执行



> Java 堆

一般所说的 “堆” 就是指 Java 堆，是用来存放 Java 对象的，每一个 Java 对象都是存放在堆中的

Java 堆**被所有线程共享**的，Java 内存结构中的大头，占用了大部分的空间，是 GC （垃圾收集器）的主要管理区域

Java 堆又分为**年轻代**和**老年代**，**永久代（1.8之前）**

1. 年轻代

   - Eden 区：对象**刚创建**的时候，存放在 Eden 区

   - Survivor 区（Survivor From、Survivor To）

     GC 回收的时候，将 Eden 不需要回收（存活）的对象存入 Survivor From 区，在下一次回收的时候，将 From 区中不需要回收的对象存入到 To 区，然后清理 From 区，在下下一次回收的时候，将 To 区中不需要回收的对象存入 From 区，再清理 To 区，以此循环...... 每次回收之后，存活下来的对象**年龄都会 +1**，年龄增加到一定程度，移动到老年代中

2. 老年代

   存放生命周期较长的对象

3. 永久代

   JDK 1.8 之前将**类的信息（全部）**存放在永久代中，JDK 1.8 之后去掉了永久代，将**类的信息（不包括静态成员）**存放在**元空间**，元空间是方法区的实现，方法区只是一种概念

   **元空间使用的是本地内存**，永久代使用的是 JVM 内存

   本地内存有多大，元空间就有多大，不再受限于 JVM 内存的大小，相当于开辟出更多的区域可以使用，效率更高



> 虚拟机栈

通常所说的**栈**就是**虚拟机栈**，Java 方法的执行是在虚拟机栈中完成，栈中存放的是栈帧，每个栈帧对应一个被调用的方法，方法的执行其实就入栈和出栈的过程

栈帧**主要**包括：

1、局部变量表（Java 方法中用到的变量）

2、操作数栈（数据入栈出栈，包含运算符栈）

3、动态链接（方法的返回地址，方法的出口）

每一个方法的执行，JVM 都会创建一个栈帧，并且将栈帧压入 Java 栈中，方法执行完毕，该栈帧出栈



##  字符串常量池 

内存中的一块特定的区域，专门用来存放字符串对象， 为了节省空间。 

String str = new String("abc")； 

String str2 = new String("abc"); 

通过构造器的方式创建字符串对象，直接将创建好的对象在堆内存中存放，不考虑是否有重复，

而使用字符串常量池，获取一个对象的时候，首先在字符串常量池中查找是否存在，如果存在，直接返回，否则再创建新的对象。

## 包装类常量池 

是一种池化技术，与JVM无关

除了通过构造器，其他创建对象的方式都会使用常量池。 

包装类使用常量池有取值区间的限制，**-128到127之间**会使用常量池，一旦超过这个范围，不会使用常量池， 而是使用堆。





# JMM

## 工作内存

工作内存，当一个线程对数据进行操作的时候，不会直 

接操作主内存，而是会将 

主内存中的数据进行复制，复制到工作内存中，线程操 

作的是工作内存中的数据，操作完成之后，再将工作内存中的数据同步到主内存中


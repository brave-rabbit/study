# 面向对象

思想：将程序模块化

- 对象和类

类是对象的抽象化描述，对象是类的具体实例

三大特征：封装、继承、多态



## 定义类

```java
修饰符 class 类名{											
    //定义属性、方法
    修饰符 数据类型 属性名
    修饰符 返回值类型 方法名（参数列表）{
           方法体
    }
}
//举例
public class Dog{
    private String name;
    public void eat(){
        //方法体
    }
}
```

类中包括：成员变量和成员方法（通过实例化对象去访问）



## 构造函数  |  构造方法 | 构造器（同一个概念）

构造函数是一种特殊的方法，普通方法是用来描述动作的，构造方法是用来创建对象（实例化对象）的

**要求：**

- 方法名必须于类名一致
- 不用定义返回类型（不要写）

**分类：**

- 无参构造函数

**在一个类中系统自动创建无参构造函数，如果自定义了有参构造函数，系统则不会创建无参构造函数**

- 有参构造函数



## 成员（全局）变量和局部变量

变量名相同，局部变量的**优先级**高于成员变量 

- 局部变量（在方法**中**声明）

作用域：定义该变量的方法中

初始值：**不会自动赋初始值**（不赋值就报错）

- 成员变量（在方法**外、类中**声明）

作用域：整个类中

初始值：**自动赋初始值**，具体什么值看数据类型	



------



# 封装

封装是指将类的属性隐藏在内部，外部不能直接访问和修改

核心思想：尽可能地将属性私有化（private），对外提供方法来访问和修改（ set/get 方法），也可以添加逻辑处理来实现过滤功能 



------



# 继承

继承是用来描述类之间的关系，即一个类继承另一个类中的属性和方法，被继承的类叫**父类**，继承父类的类叫**子类**

```java
public class 子类名 extends 父类名
```

Java 中的继承是单继承，也就是说一个子类只能有一个**直接父类**

（一个类只能继承一个类，但是一个类可以被多个类）

**继承可以传递：孙子类可以继承父类的属性**

**实现也可以传递：父类实现的接口，子类也自动实现了**



**子类只能继承父类所有的非 private 属性和方法，构造函数无法继承**，

```java
public class Son extends Parent{
    public static void main(String[] args) {
        Son son =new Son();
        //访问私有成员变量
       	son.id;		 	//错误访问
        son.getId(); 	//正确访问
        
        //访问私有成员方法
        son.test(); 	//错误访问
        son.usetest();	//正确访问
    }
}

public class Parent {
    private int id=2;
    private void test(){
       System.out.println("父类私有方法");
    }
    public int getId() {
        return this.id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public void usetest(){
        test();
    }
}
```







## 子类与父类

创建一个子类对象时，会自动先创建一个父类对象（**通过无参构造**）

```java
public class Demo extends Parent{

    public Demo() {
		//super();
    }
}
```

如果子类构造函数中没有 super()，系统会自动调用父类的无参构造

如果子类构造函数中有 super()，系统就不调用父类的无参构造，最终只调用一次 super()

如果子类构造函数中有 super(参数列表)，系统不会调用父类的无参构造，而会调用父类的有参构造

**注意：在子类构造函数中，super（[参数列表]） 只能使用一次，且必须是第一个语句**



- super

通过 super 访问父类的构造方法、普通方法、成员变量

```
访问构造方法：super（[参数列表]）				
访问普通方法：super.方法名（[参数列表]）
访问成员变量：super.成员变量
```

**在子类的构造方法中，可以通过 super 访问父类的构造方法（必须是第一句）和普通方法**

**在子类的普通方法中，只能通过 super 访问父类的普通方法**



## 访问权限

访问权限修饰符：public、protected、默认修饰符（不写）、private（**不能修饰局部变量**）

public > protected > default > private

| 访问权限  | 同一个类 | 同包 | 子类（不同包） | 非子类（不同包） |
| :-------- | :------: | :--: | :------------: | :--------------: |
| public    |    是    |  是  |       是       |        是        |
| protected |    是    |  是  |       是       |        否        |
| default   |    是    |  是  |       否       |        否        |
| private   |    是    |  否  |       否       |        否        |



------



# 多态

⼀个事物具有多种表现形态，在 Java 程序中，定义⼀个⽅法，在具体的⽣成环境中根据不同的需求呈现不同的业务逻辑，**多态的前提是继承**

```java
//定义一个方法
public void test(Parent partent){}

//调用方法
Son son=new Son();		//构建一个子类son，Son 继承 Parent
test(son);				
```

通俗来说：**可以用子类代替需要的父类** ，这就是多态

具体使用：

1.定义方法时形参类型为父类，实际调用方法时传入子类类型的参数

2.定义方法时返回值类型为父类，实际调用方法时返回子类

原理：**父类引用可以指向子类对象** （子类引用不能指向父类，除非强制转换）

```java
Parent dzx=new Son();	   //Son继承了Parent，dzx为父类引用，dzx指向Son对象
Son abc=(Son)dzx;		   //使用强制转换，子类引用指向父类
```

**（重要）父类强制转换成子类的特点:** 

- 父类转换成子类不能自动完成 
- 父类转换成子类的前提是父类的**真身**是这个子类
- 如果这个父类的真身是子类B,则不能强制转换成子类A,只能转换成B.



## 方法重写（覆盖）

⼦类在继承⽗类⽅法的基础上，对⽗类⽅法重新定义并覆盖的操作叫做⽅法重写（覆盖）

**父类的构造方法不能被重写**，方法重写的规则：

1.父子类的**方法名相同**

2.父子类的方法**参数列表相同**

3.子类方法的返回值与父类方法的返回值**类型相同**或者**是其子类**

4.子类方法的访问权限不能**小于**父类



## 方法重载

方法重载是指在**同一个类**中定义多个同名的方法，但要求每个方法具有不同的参数列表

**构造函数可以重载**，方法重载的规则： 

1.方法名**相同**

2.参数列表**不同**（类型、个数、顺序）

3.返回值类型**可以不同**（只有返回值类型不同不构成重载）

4.方法的修饰符**可以不相同**



```java
//只有形参的名称不同，不构成方法重载
public int test(int a,int b){}
public int test(int c,int d){}

//不构成重载
public void test(int a,int b){}
public int test(int c,int d){}
```



## 子父类属性方法重复

关于 JAVA 前期和后期绑定

访问修饰符并不影响属性的覆盖

- 属性覆盖

```java
Father{
    int id = 1;
    static int b =1;
}

Son extends Father{
    int id = 2;
    static int b =2;
}

Father f = new Son();
f.id  //id = 1		访问的是父类，看左边
f.b   // b = 1		访问的是父类，看左边	
```

使用父类引用指向子类对象，并且通过父类引用去访问时：

**如果父类和子类都拥有同样的成员变量，父类会覆盖掉子类，从而访问的是父类**

如果父类有，子类没有，访问的是父类

如果父类没有，子类有，编译报错

如果父类，子类都没有，编译报错



- 方法覆盖

```java
public class Fu {
    void a(){
        System.out.println(1);
    }
    static void test(){
        System.out.println("fu....");
    }
}

public class Zi extends Fu{
    void a(){
        System.out.println(2);
    }
    static void test(){
        System.out.println("zi....");
    }
}

Fu f = new Zi();
f.test();		//fu...	访问的是父类
f.a();			//2		访问的是子类
```

使用父类引用指向子类对象，并且通过父类引用去访问时：

如果是普通方法，看右边

如果是静态方法，看左边，（静态属于类，不属于对象）



总结：

```java
Father f = new Son();
```

成员变量：编译**看左边**（如果父类中没有该变量，会报错，反之），运行看**左**边（**最终访问的父类中的成员变量**）

成员方法：编译**看左边**（如果父类中没有该方法，会报错，反之），运行看**右**边（**调用的是子类中重写后的方法**）

注意：**静态变量和静态方法属于类（在编译阶段就执行了）**，使用时**看左边**（调用该类中的方法或属性）



总而言之，只要是属性，访问的都是左边的，如果是方法，普通方法访问的是右边；静态方法访问的是左边

------



# 抽象

**抽象方法和抽象类**

- 抽象方法：只有声明，没有方法体，用 abstract 修饰

```java
public abstract void 方法名();
```

**一旦类中定义了抽象方法，则类也必须声明为抽象类**

- 抽象类

```
public abstract class 类名{
}
```

**抽象类有构造方法，但不能调用**（抽象类不能被**实例化**）

抽象类中可以**没有**抽象方法，但是**包含**了抽象方法的类必须是抽象类

如果一个类继承的父类是抽象类，那么这个类必须（实现）重写父类**所有的抽象方法**，不然的话必须将这个类定义为**抽象类**



# 内部类

在类里面定义类

```java
class A{
    
    class B{
        
    }
}
```



内部类对象的创建：

- **非静态**内部类对象的创建依赖于外部类对象

```java
A.B t = new A().new B();
```

- **静态**内部类对象的创建不需要依赖外部类对象

```java
A.B t = new A.B();
```



# 类实例化顺序

父类静态成员变量/代码块-->

子类静态成员变量/代码块-->

父类非静态成员变量/代码块-->父类构造函数-->

子类非静态成员变量/代码块-->子类构造函数

**（静态只执行一次）**

**（成员变量和代码块根据书写顺序执行）**














# JVM概述

![1625223746735](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625223746735.png) 



# 五大部分

**JVM 可大致分为5大部分：**

- 类加载器（Class Loader）：加载字节码文件到内存
- **运行时数据区（Runtime Data Area）**：JVM 核心内存空间的结构模型（包括方法区、虚拟机栈、本地方法栈、堆、程序计数器）
- 执行引擎（Execution Engine）：对 JVM 指令进行解析，翻译成机器码，提交给操作系统
- 本地库接口（Native Interface）：供 Java 调用的融合了不同开发语言的原生库
- 本地方法库（Native Libraies）：Java 本地方法的具体实现

![1625223991016](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625223991016.png)



# 线程

​	这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。Hotspot JVM 中的Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的CPU 上。当原生线程初始化完毕，就会调用Java 线程的run() 方法。当线程结束时，会释放原生线程和Java 线程的所有资源



**HotspotJVM 后台运行的系统线程主要有下面几个：**

|                         |                                                              |
| ----------------------- | ------------------------------------------------------------ |
| 虚拟机线程（VM thread） | 这个线程等待JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈dump、线程暂停、线程偏向锁（biased lo |
| 周期性任务线程          | 这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。 |
| GC 线程                 | 这些线程支持JVM 中不同的垃圾回收活动。                       |
| 编译器线程              | 这些线程在运行时将字节码动态编译成本地平台相关的机器码       |
| 信号分发线程            | 这个线程接收发送到JVM 的信号并调用适当的JVM 方法处理。       |



# Java的四种引用方式

**java对象的引用包括：**

- 强引用

- 软引用

- 弱引用
- 虚引用

**Java中提供这四种引用类型主要有两个目的：**

- 可以让程序员通过代码的方式决定某些对象的生命周期；
- 有利于JVM进行垃圾回收。



## 1. 强引用

是指创建一个对象并把这个对象赋给一个引用变量，这个引用变量就是一个强引用

当一个对象被强引用变量引用时，它处于可达状态，它是**不可能被垃圾回收机制回收**的，即使该对象以后永远都不会被用到 JVM 也不会回收，因此强引用是造成Java内存泄漏的主要原因之一	

如果该对象与强引用的关系**断开**，那么此对象将会被回收

如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象



## 2.  软引用

软引用需要用 **SoftReference** 类来实现，对于**只有**软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中，比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性

```java
MyObject aRef = new  MyObject();  
SoftReference aSoftRef=new SoftReference(aRef); 
//SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收,get()方法返回Java对象的强引用
//此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强引用对象。
aRef = null;  
//此后，这个MyObject对象成为了软引用对象
```



## 3. 弱引用

弱引用需要用 **WeakReference** 类来实现，它比软引用的生存期更短，对于**只有**弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存



## 4. 虚引用

虚引用需要 **PhantomReference** 类来实现，与前面的软引用、弱引用不同，它并不影响对象的生命周期，如果一个对象与虚引用关联，则跟没有引用一样，在任何时候都可能被垃圾回收器回收

它不能单独使用，必须和引用队列联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动

虚引用的主要作用是跟踪对象被垃圾回收的状态



# 一、JAVA 内存管理

简单理解： java process memory = JVM memory + native memory

jvm 内存区域主要包括**运行时数据区**

**直接内存是 native memory**



## 1. 直接内存

- 直接内存不是虚拟机运行时数据区的一部分，**也不是《Java虚拟机规范》中定义的内存区域。**

- 直接内存是Java堆外的、直接向系统申请的内存区间。

- 使用Native函数库直接分配堆外内存, 将 **DirectByteBuffer** 对象作为这块内存的引用进行操作



## 2. 运行时数据区

包括：

- 线程私有区域：程序计数器、虚拟机栈、本地方法区
- 线程共享区域：JAVA堆、方法区



**线程私有数据区域**生命周期与线程相同, 依赖**用户线程**的启动/结束而创建/销毁(在Hotspot VM内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)

**线程共享区**域随**虚拟机**的启动/关闭而创建/销毁

![1619351748311](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1619351748311.png)

![1625225873592](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625225873592.png)

 

### 2.1 程序计数器(线程私有)

​	占用内存较小，是**当前**线程所执行的字节码（JVM 指令）**行号指示器**，JVM 通过改变计数器的值来选取下一条要执行的指令，多线程之间的**程序计数器相互独立**（为了保证每个线程恢复之后都能回到之前中断的位置，进而继续执行），互不影响

​	正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是Native方法，则为空。

​	这个内存区域是唯一一个在虚拟机中没有规定任何 **OutOfMemoryError** 情况的区域



### 2.2 虚拟机栈(线程私有)

​	是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程

栈帧**主要**包括：

1、局部变量表（Java 方法中用到的变量）

2、操作数栈（数据入栈出栈，包含运算符栈）

3、动态链接（指向运行时常量池的方法引用）

4、方法出口

栈帧随着方法调用而**创建**，随着方法结束而**销毁**——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。



### 2.3 本地方法栈(线程私有)

​	本地方法区和Java Stack作用类似, 区别是**虚拟机栈为执行Java方法服务**, 而**本地方法栈则为Native方法服务**, 如果一个VM实现使用C-linkage模型来支持Native调用, 那么该栈将会是一个C栈，但HotSpot VM直接就把本地方法栈和虚拟机栈合二为一



### 2.4 Java 堆（线程共享）

一般所说的 “堆” 就是指 Java 堆，是用来存放 Java 对象的，每一个 Java 对象都是存放在堆中的

Java堆**被所有线程共享**的，Java 内存结构中的大头，占用了大部分的空间，是 GC （垃圾收集器）的主要管理区域

Java堆从GC的角度还可以细分为：

#### 2.4.1 新生（年轻）代

​	是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发 **MinorGC** 进行垃圾回收。新生代又分为Eden区、ServivorFrom、ServivorTo三个区

- Eden 区：**Java新对象的出生地**（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。

- Survivor From 区：上一次GC的幸存者，作为这一次GC的被扫描者
- Survivor To 区：保留了一次MinorGC过程中的幸存者



**MinorGC的过程（复制->清空->互换）**：

**MinorGC采用复制算法**

**1、eden、servicorFrom 复制到ServicorTo，年龄+1**

​	首先，把Eden和Servivor From区域中存活的对象复制到Servicor To区域（如果有对象的年龄以及达到了老年的标准（15），则赋值到老年代区），同时把这些对象的年龄+1（如果Servicor To不够位置了就放到老年区）；

**2、清空eden、servicor From**

​	然后，清空Eden和Servicor From中的对象；

**3、Servicor To和Servicor From互换**

​	最后，Servicor To和ServicorFrom互换，原Servicor To成为下一次GC时的Servicor From区。



总结：每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中，然和清除该两块的空间



#### 2.4.2 老年代

主要存放应用程序中生命周期长的内存对象。 

​	老年代的对象比较稳定，所以 **MajorGC** 不会频繁执行。

- 在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。
- 当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。

MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象 MajorGC 的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常



#### 2.4.3 永久代（jdk1.8之前）

​	指内存的永久保存区域，主要存放 Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域，它和和存放实例的区域不同,**GC不会在主程序运行期对永久区域进行清理**。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常

- jdk1.8 之后，永久代被**元空间**取代

- 元空间与永久代之间最大的**区别**在于：元空间并不在虚拟机中，而是**使用本地内存**。因此，默认情况下，元空间的大小仅受本地内存限制

- 类的**元数据放入native memory, 字符串池和类的静态变量放入java堆中**，这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制



### 2.5 方法区（线程共享）

​	存储被 JVM 加载**的类信息**、**常量**、**静态成员变量和字符串常量池（jdk 1.8之前），即时编译器编译后的代码等数据**，方法区是一种概念、规范（抽象），**永久代**（堆中）是方法区的一种实现，**元空间**（本地内存）也是方法区的一种实现（jdk8之后）

运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中

Java 中静态/运行时常量池并非特指保存 final 常量，它还保存诸如字面量、类和接口全限定名、字段、方法名称、修饰符等永恒不变的东西。

**注意：**

- 提到常量池，一般指的是方法区中的静态/运行时常量池。
- 字符串池/字符串常量池/字符串对象池/String Pool/String Table 都可以看作一个东西
- 包装类对象池技术和 JVM 的常量池没有任何关系，是 Java 在类封装里实现的



# GC

- GC：垃圾收集器

- Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的 Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂（复制）
- Major GC/Full GC：老年代GC，指发生在老年代的GC（标记整理）



## 1. 确认垃圾

判定哪些对象为可回收对象

目前Java虚拟机的主流垃圾回收器采取的是可达性分析算法



### 1.1 引用计数法（reference counting）

​	在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一**个对象如果没有任何与之关联的引用**，即他们的引用计数都为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象，此方法**不能解决循环引用问题**



### 1.2 可达性分析

​	为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列被称为 **“GC roots”** 的对象作为起点搜索。如果在 “GC roots” 和一个对象之间**没有可达路径**，则称该对象是不可达的。要注意的是，**不可达对象不等价于可回收对象**。**不可达对象变为可回收对象至少要经过两次标记过程，两次标记后如果仍然是可回收对象，则将面临回收。**

对象可达指的就是：**双方存在直接或间接的引用关系**

**GC Roots就是对象**，而且是JVM确定**当前绝对不能被回收**的对象	

GC Roots可以理解为由堆外指向堆内的引用，GC Roots包括（但不限于）以下几种：

- 已加载类的静态变量引用的对象
- Java 方法栈桢中的局部变量引用的对象
- 常量池引用的对象
- JNI本地方法栈中引用的对象
- 被同步锁持有的对象



## 2. GC算法

### 2.1 标记-清除算法（Mark-Sweep）

最基础的垃圾回收算法，分为两个阶段：**标记**和**清除**

1. 标记阶段：首先通过根节点，**标记所有从根节点开始的可达对象**，**未被标记**的对象就是垃圾对象
2. 清除阶段：清除所有未被标记的对象

![1625448449876](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625448449876.png)

缺点：

- 效率不高，标记和清除的效率都很低
- 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作



### 2.2 复制算法（Copying）

为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法：

1. 将原有的内存空间分为两块，每次只使用一块
2. 在垃圾回收时，将正在使用的内存中的存活对象复制到未被使用的内存块中，然后清除正在使用的内存块中的所有对象
3. 交换两个内存的角色，完成垃圾回收

![1625448587069](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625448587069.png)

缺点：这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying算法的效率会大大降低



### 2.3 标记—整理（压缩）算法（Mark-Compact）

1. 标记阶段：先通过根节点，标记所有从根节点开始的可达对象，未被标记的为垃圾对象
2. 整理阶段：将所有的存活对象压缩到内存的一端，之后清理端边界外所有的空间

![1625448929105](C:\Users\86185\AppData\Roaming\Typora\typora-user-images\1625448929105.png)

它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它**并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端**。之后，清理边界外所有的空间



### 2.4 三种算法的比较

- 效率： 复制 > 标记整理 > 标记清除  (此处的效率只是简单的对比时间复杂度，实际情况不一定如此)

- 内存利用率： 标记整理 > 标记清除 > 复制

- 内存整齐度： 复制 = 标记整理 > 标记清除



### 2.5 分代收集算法

当前商业虚拟机的垃圾收集都采用“分代收集算法”

 这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块区域

 一般是将Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法

- 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。


- 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，必须使用**标记—清理**或**标记-整理**算法来进行回收。



新生代GC（minor gc）----------指发生在新生代的垃圾回收动作，因为JAVA对象大多数都是朝生夕死的特性，所以minor gc非常平凡，使用复制算法快速的回收。

 老年代GC（major gc）—— 指发生在老年代的垃圾回收动作，用的是“标记--整理”算法。



### 2.6 分区收集算法

​	分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间, 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次GC所产生的停顿



## 3. GC收集器

























